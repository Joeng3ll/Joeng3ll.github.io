<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Joeng_ll"><title>前端缓存 · Joeng_ll</title><meta name="description" content="Disk Cache  Vs  Memory Cache一、内存和硬盘内存：计算机运行过程中会把需要的计算数据调到内存中进行运算。主要分为RAM（随机存储器）、ROM（只读存储器）、Cache（高速缓存）。
硬盘：计算机的“外存”，用来存放暂时不用的信息。硬盘上的数据只有被装入内存后才能被处理。
二"><meta name="keywords" content="前端"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/avator2.png" style="width:127px;"><h3 title=""><a href="/">Joeng_ll</a></h3><div class="description"><p>Be Patient &amp; Modest.</p></div></div></div><ul class="social-links"><li><a href="http://github.com/Joeng3ll"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="https://joeng3ll.github.io/"></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/avator_2018_7_2.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>前端缓存</a></h3></div><div class="post-content"><h3 id="Disk-Cache-Vs-Memory-Cache"><a href="#Disk-Cache-Vs-Memory-Cache" class="headerlink" title="Disk Cache  Vs  Memory Cache"></a>Disk Cache  Vs  Memory Cache</h3><h4 id="一、内存和硬盘"><a href="#一、内存和硬盘" class="headerlink" title="一、内存和硬盘"></a>一、内存和硬盘</h4><p>内存：计算机运行过程中会把需要的计算数据调到内存中进行运算。主要分为RAM（随机存储器）、ROM（只读存储器）、Cache（高速缓存）。</p>
<p>硬盘：计算机的“外存”，用来存放暂时不用的信息。硬盘上的数据只有被装入内存后才能被处理。</p>
<h3 id="二、Memory-Cache-the-lookahead-downloader"><a href="#二、Memory-Cache-the-lookahead-downloader" class="headerlink" title="二、Memory Cache  : the lookahead downloader"></a>二、Memory Cache  : the lookahead downloader</h3><blockquote>
<p>“Have you heard of the preloader? It has sharp teeth all made of regex and it fetches everything it lays its eyes on”                                                                ——     <a href="https://calendar.perfplanet.com/2013/big-bad-preloader/" target="_blank" rel="external">https://calendar.perfplanet.com/2013/big-bad-preloader/</a></p>
</blockquote>
<p>Memory Cache相当于内存中的缓存，<strong>几乎所有</strong>的网络请求资源都会被<strong>自动</strong>加入到其中。但是由于浏览器占用的内存不能无限扩大，所以一个Tab页面关闭后，本次浏览的Memory Cache即失效（为了给后来的Tab腾出位置）。</p>
<p><strong>作用</strong>：保证了一个页面中如果有俩个相同的请求都实际只会被请求最多一次，不造成浪费。</p>
<p><strong>几乎所有的网络请求都能进入Memory Cache</strong>主要理解为<strong>preloader</strong>与<strong>preload</strong>俩个内容：</p>
<p>1、Preloader: 当页面中有多个Javascript脚本或是其他CSS外部文件等资源时，浏览器会一直等待当前资源解析完才去下载另一个外部资源，在这个解析的过程中network就是闲置的，而简单来说Preloader的作用就是找到当前页面需要加载的外部资源，在解析资源过程中提前加载后续外部资源。</p>
<p>2、Preload: <link rel="preload">   显示指定的预加载资源。</p>
<h3 id="三、Disk-Cache"><a href="#三、Disk-Cache" class="headerlink" title="三、Disk Cache"></a>三、Disk Cache</h3><p>实际存储于文件系统中的，允许相同的资源在跨会话、跨站点的情况下使用。会根据HTTP头信息中的各类字段来判定哪些资源可以缓存以及缓存时效。当命中缓存后，会从硬盘中读取资源，速度低于内存，但是高于网络请求。</p>
<h3 id="四、Service-Worker-Application-gt-Cache-Storage"><a href="#四、Service-Worker-Application-gt-Cache-Storage" class="headerlink" title="四、Service Worker        Application -&gt; Cache Storage"></a>四、Service Worker        Application -&gt; Cache Storage</h3><p>Memory Cache和Disk Cache都是浏览器内部根据我们设置的某些字段来进行判断和进行的，而Service worker给了我们直接操作缓存的能力，当然这个缓存是指 “Application -&gt; Cache Storage”中的缓存区。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-25</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2018/09/25/前端缓存/,Joeng_ll,前端缓存,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2018/09/10/record-for-ts/" title="record-for-ts" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>